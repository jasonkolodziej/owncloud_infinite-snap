#? This is a basic workflow to help you get started with Actions
name: CI-Dispatcher
#? Controls when the workflow will run
on:
  workflow_dispatch:
  schedule:
    #?        ┌───────────── minute (0 - 59)
    #?        │ ┌───────────── hour (0 - 23)
    #?        │ │ ┌───────────── day of the month (1 - 31)
    #?        │ │ │ ┌───────────── month (1 - 12 or JAN-DEC)
    #?        │ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT)
    #?        │ │ │ │ │
    #?        │ │ │ │ │
    #?        │ │ │ │ │
    #?        * * * * *,-
    - cron: "30 2 * * *"

jobs:
  release_dispatch:
    #? Reference: https://github.com/marketplace/actions/snapcraft-multiarch-build
    strategy:
      matrix:
        os:
          - ubuntu-latest
        platform:
          - arm64
          - amd64
    #? The type of runner that the job will run on
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
    steps:
      - name: Fetch Repository Release Information
        #? https://docs.github.com/en/rest/releases/releases?apiVersion=2022-11-28#get-the-latest-release
        id: latest-release
        run: |
          echo "release_info=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          /repos/${{env.OWNER}}/${{env.REPOSITORY}}/releases/latest)\n" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: owncloud
          REPOSITORY: ocis

      - name: Extract tag_name
        id: extract-tag
        run: |
          echo "tag_name=${{ fromJson(steps.latest-release.outputs.release_info).tag_name }}" >> $GITHUB_OUTPUT
          echo "tag=$(echo ${{ fromJson(steps.latest-release.outputs.release_info).tag_name }} | tr -d 'v')" >> $GITHUB_OUTPUT

      #? Refrence: https://github.com/actions/cache/tree/main
      #? A cache today is immutable and cannot be updated. But some use cases require the cache to be saved even though
      #? there was a "hit" during restore.
      #? To do so, use a key which is unique for every run and use restore-keys to restore the nearest cache. For example:
      - uses: actions/cache@v4
        #* Try and restore a cached version if possibe
        id: cached
        # continue-on-error: true
        with:
          path: ocis
          key: ocis-${{ steps.extract-tag.outputs.tag }}-${{ runner.os }}-${{ matrix.platform }}-${{ hashFiles('ocis') }}
          restore-keys: |
            ocis-${{ steps.extract-tag.outputs.tag }}-${{ runner.os }}-${{ matrix.platform }}-
            ocis-${{ steps.extract-tag.outputs.tag }}-${{ runner.os }}

      - name: Determine if new
        id: is-new
        run: echo "is_new=${{ steps.cached.outputs.cache-hit != 'true' }}" >> $GITHUB_OUTPUT

      - name: Grab binary via Cache
        #* Download the latest binary
        id: grab
        if: ${{ steps.is-new.outputs.is_new }}
        run: |
          echo "latest cached binary doesn't exist, downloading..."
          export OS_FAMILY=$(echo "${{ runner.os }}" | tr '[:upper:]' '[:lower:]')
          curl --fail https://download.owncloud.com/ocis/ocis/stable/${{ steps.extract-tag.outputs.tag }}/ocis-${{steps.extract-tag.outputs.tag}}-${OS_FAMILY}-${{matrix.platform}} --output ocis
          # set file to be executable
          # chmod +x ./ocis

      #? Refrence: https://github.com/actions/cache/tree/main
      - uses: actions/cache/save@v4
        #? https://github.com/actions/runner/blob/main/docs/adrs/0274-step-outcome-and-conclusion.md
        # if: ${{ steps.cached.outputs.cache-hit != 'true' && steps.grab.conclusion == 'success' }}
        if: ${{ steps.is-new.outputs.is_new && steps.grab.conclusion == 'success' }}
        id: cache
        with:
          path: ocis
          key: ocis-${{ steps.extract-tag.outputs.tag }}-${{ runner.os }}-${{ matrix.platform }}-${{ hashFiles('ocis') }}

      - name: Repository Dispatch
        if: ${{ steps.is-new.outputs.is_new && steps.cache.conclusion == 'success' }}
        #? https://github.com/marketplace/actions/repository-dispatch
        uses: peter-evans/repository-dispatch@v3
        with:
          #? It needs the following permissions on the target repositories:
          #?    - contents: read & write
          #?    - metadata: read only (automatically selected when selecting the contents permission)
          token: ${{ secrets.PAT }}
          # repository: username/my-repo
          event-type: dispatch-released
          client-payload: |-
            {
              "tag_name": "${{ steps.extract-tag.outputs.tag_name }}", 
              "tag": "${{ steps.extract-tag.outputs.tag }}",
              "is_new": ${{ steps.is-new.outputs.is_new }},
              "cache_key": "ocis-${{ steps.extract-tag.outputs.tag }}-${{ runner.os }}-${{ matrix.platform }}-${{ hashFiles('ocis') }}",
              "build_platform": "${{ matrix.platform }}",
              "build_os": "${{ matrix.os }}"
            }
