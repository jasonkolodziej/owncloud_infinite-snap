#!/bin/bash -e
#? Reference: https://snapcraft.io/docs/adding-snap-configuration#heading--interpreting

CONFIG_FILE_LOCATION="$OCIS_CONFIG_DIR/ocis.yaml"
CONFIG_FILE_LOCATION="../../ocis/config/ocis.example.yaml"

# export NEXTCLOUD_CONFIG_DIR="$SNAP_DATA/nextcloud/config"
# export NEXTCLOUD_DATA_DIR="$SNAP_COMMON/nextcloud/data"

#* PRIVATE_KEY_TERMS
#*   *secret* *password* *key*

#! Not Private Key Terms -
#? Collects the 'non-private' configuration options then sets the configuration via shell
_not_private_key_terms() {
    # yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p != "*secret*") | select(.p != "*key*") | select(.p!= "*password*") | select(.tag != "!!map") | select(.isKey == false) ]' ${CONFIG_FILE_LOCATION}
    non_priv=$(yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p != "*secret*") | select(.p != "*key*") | select(.p!= "*password*") | select(.tag != "!!map") | select(.isKey == false) | { .p:.value } ]' ${CONFIG_FILE_LOCATION})
    non_priv=$(echo -e "${non_priv[@]}" | tr -d '-' | tr ':' '=' | tr -d ' ')
    for line in $non_priv; do
        set_config_shell 'false' $line
    done
    # echo $non_priv
}

#! Private Key Terms -
#? Collects the 'private' configuration options then sets the configuration via shell
_private_key_terms() {
    # yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p != "*secret*") | select(.p != "*key*") | select(.p!= "*password*") | select(.tag != "!!map") | select(.isKey == false) ]' ${CONFIG_FILE_LOCATION}
    secrets=$(yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p == "*secret*") | select(.tag != "!!map") | select(.isKey == false) | { .p:.value }]' ${CONFIG_FILE_LOCATION})
    keys=$(yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p == "*key*") | select(.tag != "!!map") | select(.isKey == false) | { .p:.value } ]' ${CONFIG_FILE_LOCATION})
    passwords=$(yq '[... | { "p": path | join("."), "isKey": is_key, "tag": tag, "value": eval(path) } | select(.p == "*password*") | select(.tag != "!!map") | select(.isKey == false) | { .p:.value } ]' ${CONFIG_FILE_LOCATION})
    #* clean up ==> | tr -d  '-' | tr ':' '=' | tr -d ' '
    privs=$(echo -e "${secrets[@]} \n ${keys[@]} \n ${passwords[@]}" | tr -d '-' | tr ':' '=' | tr -d ' ')
    for line in $privs; do
        set_config_shell 'true' $line
    done
    # echo "${secrets[@]} \n ${keys[@]} \n ${passwords[@]}"

}

#* Set Config Shell -
#? sets the value/values of the config
#* @param {is_priv} - boolean, default false
#* @param {arr_in} - array, e.g. [ this.conf.param1='something_to_be_set1' this.conf.param2='something_to_be_set2' #... ]
set_config_shell() {
    local is_priv=${1:='false'}
    local arr_in=(${2//=/ })
    local param=${arr_in[0]}
    local val=${arr_in[1]}

    #echo $param
    #echo $val
    if [ "$is_priv" == 'true' ]; then
        echo "setting private configuration as==> 'private.${param}=${val}'"
        # snapctl set "private.${param}"=${val}
    else
        echo "setting configuration as==> '${param}=${val}'"
        # snapctl set ${param}=${val}
    fi

    # snapctl set ${param}="$val"
    # snapctl set ${1}="$2"
}

#* Set All Defaults From YAML -
#?  Invokes the splitting of 'private' & 'non-private' configuration options from
#*  the applications YAML file and sets them with-in the context of `snapctl`
set_all_defaults_from_yaml() {
    echo 'Setting all configuration options'
    #? set non private
    _not_private_key_terms
    #? set private
    _private_key_terms
}

#* Get Config -
#?  Requests the current/default config's value if nothing is yet set and returns the value
#* @param {conf_key} - the key to retrieve from the configuration file, default: NIL (a.k.a: grab all configs)
get_config_shell() {
    local conf_key=${1}
    # local config_option=

    # if [ -n "$conf_key" ]; then
    # local config_option="$(snapctl get ${conf_key})"
    # fi
    if [ -z "$config_option" ]; then
        config_option="$(yq ".${conf_key}" ${CONFIG_FILE_LOCATION})"
    fi
    # yq ".${1}" ${CONFIG_FILE_LOCATION}
    echo "$config_option"
}

#* Update YAML Inplace -
#?  Changes the config in-place
#* @param {updater} - the key to be updated
_update_yaml_inplace() {
    local updater="$@"
    yq -i ".$updater" ${CONFIG_FILE_LOCATION}
}

#* Update YAML -
#? Produces output of an updated yaml but doesn't change config
#* @param {in_place} - when 'true' changes the config in-place, default: 'false'
#* @param {updater} - the key to be updated
update_yaml() {
    local in_place="${1:-'false'}"
    local updater="${@:2}"
    if [ "$in_place" == 'false' ]; then
        echo 'generating a non-inplace config'
        # echo "${updater}"
        yq ".$updater" ${CONFIG_FILE_LOCATION}
    else
        echo 'editing config inplace'
        yq -i ".$updater" ${CONFIG_FILE_LOCATION}
    fi

}

_json_to_yaml() {
    # yq -Poy sample.json
    yq -Poy sample.json
}

# TODO: fix
handle_config() {
    echo 'handle_config params' $@
    local some_config="$(get_config_shell)"
    # Validate HTTP port
    #        if ! expr "$some_config" : '^[0-9]\+$' > /dev/null; then
    #               echo "\"$some_config\" is not a valid HTTP port" >&2
    #              return 1
    #     fi
    # run function from management script
    set_config "$some_config"

    # Restart example-server to apply new config
    # snapctl restart example-server
}

# handle_config

#* Alternatively, the entire set of configuration options can be dumped as JSON by adding the -d option:
#? [Reference]: https://snapcraft.io/docs/configuration-in-snaps

get_config_json() {
    echo "get_json_config"
    snapctl get -d ${SNAP_NAME}
}

set_config_json() {
    echo "set_json_config"
    yq '.' -o json ${CONFIG_FILE_LOCATION} | snapctl set -d ${SNAP_NAME}
}
